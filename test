/*@TODO:
- printf style draw_text
- gap buffer
- handle tabs better
- multiple buffers + save
- handle the order of stuff in update
- undo
- redo
- vim / kakoune or maybe emacs? basics
- smooth scrolling (see bezier curves, cubic splines)
- window resizing
- multiple font sizes
- antialiasing
- kerning
- switch from sdl?
- handle small font sizes- search
- replace
- basic parser  // propably this should be done later
     - syntax highlighthing
- matching braces
- list all defintions (functions, types, ...)
- jump to definition (also peek definition)
- jump history
- macro recording
- multiple cursors?
- basic autocomplete
- split windows
- auto indentation
- snippets?
- registers?
- better parser
- optimizations
- integrated build system (with jump to errors)
*/
#include <SDL2/SDL.h>
#include <assert.h>
#define STBI_ONLY_PNG
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"
#include <stdio.h>
#include <math.h>
#define array_length(arr) (sizeof(arr) / sizeof(*(arr)))

typedef struct Image {
	int width;
	int height;
	uint32_t *pixels;
} Image;

Image load_image(char *filename)
{
    int w, h, n;
    unsigned char *pixels = stbi_load(filename, &w, &h, &n, 4);
    if (!pixels)
    {
        printf("failed to load %s\n", filename);
        assert(0);
    }

    assert(n == 3 || n == 4);
    Image img;
    img.width = w;
    img.height = h;
    img.pixels = (uint32_t *)pixels;//malloc(w * h * 4);
    //pixels are 0xRRGGBBAA
    uint32_t *pixel = img.pixels;
    for (int y = 0; y < img.height; y++)
    {
        for (int x = 0; x < img.width; x++)
        {
			uint32_t p = *pixel;
			uint32_t r = (p >> 0)  & 0xFF;
			uint32_t g = (p >> 8)  & 0xFF;
			uint32_t b = (p >> 16) & 0xFF;
			uint32_t a = (p >> 24) & 0xFF;
            *pixel = (r << 24) | (g << 16) | (b << 8) | (a << 0);
            pixel++;
        }
    }
    //stbi_image_free(pixels);
    return img;
}

char *load_entire_file(char *filename)
{
    FILE *f = fopen(filename, "r");
    if (!f)
    {
        printf("failed to load file: %s\n", filename);
        assert(f);
        return 0;
    }
    fseek(f, 0, SEEK_END);
    long length = ftell(f);
    fseek(f, 0, SEEK_SET);
    char *result = malloc(length + 1);
    assert(result);
    fread(result, 1, length, f);
    result[length] = 0;
    fclose(f);
    //TODO: what should we do about '\r'?
    for (int i = 0; i < length;)
    {
        if (result[i] == '\r')
        {
            memmove(result + i, result + i + 1, length - i);
            length--;
        }
        else
            i++;
    }
    return result;
}

#include "texor.c"

int main(void)
{
    Image back_buffer = {
        .width = 960,
        .height = 540,
    };
    int window_width = back_buffer.width;
    int window_height = back_buffer.height;

    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window *window = SDL_CreateWindow("texor", 0, 1500,
                                          window_width, window_height, SDL_WINDOW_SHOWN);
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED|SDL_RENDERER_PRESENTVSYNC);
    SDL_SetWindowMinimumSize(window, window_width, window_height);
    //TODO: should these takes window or back_buffer width/height
    SDL_RenderSetLogicalSize(renderer, window_width, window_height);
    SDL_RenderSetIntegerScale(renderer, 1);
    SDL_Texture *screen_texture = SDL_CreateTexture(renderer,
                                                    SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING,
                                                    back_buffer.width, back_buffer.height);
    back_buffer.pixels = malloc(back_buffer.width * back_buffer.height * sizeof(uint32_t));
    assert(back_buffer.pixels);
    assert(window && renderer && screen_texture);


    unsigned int t1 = SDL_GetTicks();
    while (1)
    {
        int enter = 0, backspace = 0;
        char input_text[16];
        input_text[0] = 0;

        SDL_Event ev;
        memset(is_pressed, 0, sizeof(is_pressed));
        mouse_scroll_y = 0;
        while (SDL_PollEvent(&ev))
        {
            if (ev.type == SDL_QUIT)
            {
                return 0;
            }
            else if (ev.type == SDL_TEXTINPUT)
            {
                memcpy(input_text + strlen(input_text), ev.text.text, strlen(ev.text.text) + 1);
            }
            else if (ev.type == SDL_KEYDOWN || ev.type == SDL_KEYUP)
            {
                int is_down = (ev.type == SDL_KEYDOWN);

                SDL_Keycode code = ev.key.keysym.sym;
                if (code == SDLK_TAB && is_down)
                    memcpy(input_text + strlen(input_text), "\t", 2);
                if (code == SDLK_LCTRL)
                    is_control_key_pressed = is_down;

               // if (code == SDLK_ESCAPE)
                //    return 0;
                //TODO: change this into GetKeyboardState?
                is_pressed[ev.key.keysym.scancode] = is_down;

            }
            else if (ev.type == SDL_MOUSEBUTTONDOWN || ev.type == SDL_MOUSEBUTTONUP)
            {
                if (ev.button.button == SDL_BUTTON_LEFT)
                    is_mouse_left_button_pressed = (ev.type == SDL_MOUSEBUTTONDOWN);
            }
            else if (ev.type == SDL_MOUSEWHEEL)
            {
                static int last = 0;
                mouse_scroll_y = ev.wheel.y;
            }
        }
        SDL_GetMouseState(&mouse_x, &mouse_y);
        t1 = SDL_GetTicks();
        update_and_render_the_editor(&back_buffer, input_text);
        //printf("%d\n", SDL_GetTicks() - t1);
        SDL_RenderClear(renderer);
        SDL_UpdateTexture(screen_texture, NULL, back_buffer.pixels, window_width * 4);
        SDL_RenderCopy(renderer, screen_texture, NULL, NULL);
        SDL_RenderPresent(renderer);

    }
    return 0;
}
